# Concept Update Summary
Compared with how I defined my four concepts in [Assignment 2](https://github.com/Avril-Cui/61040-portfolio/blob/main/assignments/assignment2.md), I have made several changes. I will walk through the major updates in each concept.
## TaskCatalog
1.	Unified time representation. As pointed out by the grader, I previously mixed TimeStamp and Time types, which caused ambiguity. I standardized on using TimeStamp for attributes like deadline to maintain consistency across the concept and improve database integration.
2.	Normalized slack type. In Assignment 2, the slack attribute was sometimes treated as a String. I changed it to a Number type (representing minutes) to ensure consistency and enable arithmetic operations such as computing scheduling buffers.
3.	Removed verifyTime action. The grader noted that verifyTime violated separation of concerns, since it required access to internal scheduling data (start and end times) outside the TaskCatalog’s scope. Upon reflection, I agree. This functionality belongs to synchronization, not in task management concept.
4.	Added deleteSchedule action. To complement assignSchedule, I added a corresponding deleteSchedule action. This provides users the ability to remove a specific timeBlockId from a task’s timeBlockSet, making timeBlockSet interface symmetrical and complete.
5.	Refined dependency management. In Assignment 2, dependency updates were handled implicitly inside updateTask, which was prone to inconsistencies. I refactored this logic into explicit actions:
  - addPreDependence
	- removePreDependence
  This change makes dependency relationships clearer, ensures two-way consistency between preDependence and postDependence, and improves testability. The reason why I kept both preDependence and postDependence is that, postDependence is crucial to trace tasks back when deleteTask is called, while preDependence is important for the sync when we are scheduling tasks.
6.	General cleanup. I fixed minor issues such as typos, inconsistent capitalization (e.g., taskID -> taskId), and improved comment clarity. I also added underscore before the query _getUserTasks to note that it's a query. These changes improve readability and reduce ambiguity during implementation and testing.

## ScheduleTime
1. Unified time representation. In Assignment 2, I used the Time type for the start and end attributes of each time block. This was inconsistent with the rest of the system (e.g., TaskCatalog and AdaptiveSchedule) which use TimeStamp. I updated all time-related fields to TimeStamp to maintain consistency and enable precise scheduling and comparison across concepts.
2. Introduced internal query naming convention. The query getUserSchedule has been renamed to _getUserSchedule, following the same convention applied to TaskCatalog. This clarifies that it is a query (non-mutating) action used to fetch a user’s time blocks.
3. Clarified end-of-day filtering. The getUserSchedule specification now explicitly states that it only returns future time blocks that end before the end of the day. This refinement aligns the model with realistic daily scheduling use cases and with behavior in the implemented tests.
4. Improved assignTimeBlock logic. The original version used an implicit assumption that addTimeBlock must be called before assigning tasks. The new version integrates auto-block creation logic. If the desired block doesn’t exist, assignTimeBlock automatically creates it (following the same structure as addTimeBlock).

## RoutineLog
1. Removed Task as a direct parameterized type. In Assignment 2, RoutineLog was defined as RoutineLog [User, Task], meaning it depended directly on the Task type, while sort of violates modularity. I refactored it to RoutineLog [User] and now reference tasks only by their unique IDs (strings) rather than full task objects. This change makes RoutineLog more modular and decoupled from TaskCatalog, ensuring that activity tracking can function independently of task definitions.
2. Unified time representation. In the original version, the start and end attributes used the Time type, while other concepts used TimeStamp. I replaced all Time types with TimeStamp to maintain consistency across the system and enable cross-concept time comparison and analysis.
3. Renamed and clarified query action. Renamed getUserSessions to _getUserSessions to indicate that it is a query (non-mutating) action. This aligns with the naming convention used in the updated concepts and backend implementation.
4. Rename pauseSession to interruptSession, which is more consistent with the principle of the concept. Also enhanced the logic of interruptSession by adding stronger require statement `session has isPaused as False;`.

## AdaptiveSchedule
This is the concept that underwent the most significant redesign to improve clarity, modularity, and conceptual separation. It now achieves full independence from other concepts while retaining the ability to coordinate with them through the synchronization.

1. In previous versions (Assignments 2 and 3), the requestAdaptiveScheduleAI action explicitly took the llm as an argument. Through Piazza discussions, I realized the LLM instance should be part of the concept’s internal state, not repeatedly passed into actions. Now, GeminiLLM is defined as a field of the concept itself and initialized in the constructor. This makes the concept cleaner.
2. Previously, requestAdaptiveScheduleAI required multiple structured inputs, specifically Task, Schedule, and Routine, to provide the LLM with the full system context. This design caused cross-concept dependency: AdaptiveSchedule needs knowledge about other concepts' states, violating modularity. In the new version, the action only takes a `contexted_prompt` string as input. This prompt is pre-composed by the sync layer, which gathers information from TaskCatalog, ScheduleTime, and RoutineLog before passing it to AdaptiveSchedule action. This refactoring ensures that AdaptiveSchedule no longer depends on the internal state or structure of other concepts, achieving clean separation of concerns.
3. All time fields (start, end) now use TimeStamp instead of Time, aligning with the standard across other concepts.
4. Tasks within adaptive blocks are now referenced only by their unique task IDs (strings) rather than as full Task objects. This ensures modular independence from TaskCatalog.
5. I introduced two new explicit query actions: _getAdaptiveSchedule and _getDroppedTask. These use the same underscore prefix convention adopted throughout the system to denote pure queries (read-only operations).
6. The droppedTasks structure now explicitly includes a reason for each dropped task, improving interpretability and transparency of the LLM's decisions.

# Interesting moments
1. Initially, when I asked the context tool to generate test cases for me, the test cases either have very repetitive scenarios or are low-quality. I then decided to pass in the instruction from the assignment page. Very impressively, the test cases have boosted in quality. This shows to me how LLM will work better if we provide them with a clear, "rubric-like" guideline so it knows what are the expectations and what it should avoid doing.
	[20251015_171159.60f8c3bb](context/design/concepts/RoutineLog/testing.md/20251015_171159.60f8c3bb.md)
2. While implementing the test cases for AdaptiveSchedule, I noticed that since this is the most complicated concept for my app, the LLM generated code often have different small errors. As we have multiple conversations, the record of our conversation aggregate in the document. At that moment, when I call the context tool again to fix some error, the new code generated by the context tool is relatively low-quality that repeats errors that happen previously. Then, I decided to remove the unnecessary conversation from the document, only keeping the recent ones, and re-executed the context tool. The quality then improved a lot. I think a possible interpretation might be, the LLM lost its "attention" if the document is too long. An analogy is that, often if we ask ChatGPT to perform a long task, it does it poorly compared to doing a shorter task with less information. Below is the document where the document gets very long, and the context tool's quality declines:
	[20251018_215454.cd3f6510](context/design/concepts/AdaptiveSchedule/testing.md/20251018_215454.cd3f6510.md)
3. For concepts with clear logic and relatively simple actions, the context tool is able to generate very impressive and high quality code. An example is RoutineLog. The context tool generated a working implementation with just three trials! RoutineLog is also one of the concept specifications that was well-polished. So I think, with a clear concept specification, the LLM is very good at coding and implementing the actions.
	[20251015_173200.5e83df6e](context/design/concepts/RoutineLog/implementation.md/20251015_173200.5e83df6e.md)
4. To give the context tool more context for implementing the test cases, I also passed in the implementation files as a context. It is very interesting because while implementing the test cases, the LLM can often find issues with my implementation, then suggest a new implementation with the issues fixed. So, a lot of times, my code in src ended up being generated/finalized by the `test` file instead of the `implementation` file.
	[20251018_215447.fb2349b6](context/design/concepts/AdaptiveSchedule/testing.md/20251018_215447.fb2349b6.md)
5. Adding extra commentary notes in the implementation file improves the quality of the context tool generated code. Sometimes the concept specification is not detailed enough because I want to keep it succinct. Therefore, I find it helpful to add more comments on how I want the LLM to implement some aspects of the concept. For example, for AdaptiveSchedule, I explicitly said in the implementation file how I want the LLM to handle the GeminiLLM class. and provided a code example to that. The implementation generated by the context tool then fully considers this information and does exactly as what I expected, which is very cool.
	[20251018_185501.8680291b](context/design/concepts/AdaptiveSchedule/implementation.md/20251018_185501.8680291b.md)